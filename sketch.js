//author:
//Shiyu Lin, 11,30,2025, 

//Instructions:
//Click the button in the bottom-right corner to perform the next care action for your plants â€” watering, fertilizing, or pruning.
//Each action triggers growth or changes in the garden, and the plants will speak back to you with a gentle message.

//Introduction:
//This project is a micro-scale plant ecosystem built around a one-button interaction. 
//It uses a small corpus of personified plant phrases as its core dataset, and each simple input triggers layered growth responses within the system. 
//The work explores the reciprocal relationship between acts of care and emotional feedback: 
//every action not only alters the plantsâ€™ physical form but also prompts a linguistic response directed back at the user.
//The plants never raise their voices, but theyâ€™re always honest with you: they need you, they depend on you, they appreciate you, and every now and then, theyâ€™ll show a bit of playful spirit.

//Acknowledgements:
//Code reference:https://p5js.org/reference/p5/createButton/  
//Code Tutorial:https://www.youtube.com/watch?v=T-HGdc8L-7w  
//Inspiration source: Derived from the previous project, SproutKeysPlantingSound. 
//I upgraded the single interactive method of feeding and growing into three - watering, fertilizing, and pruning.

let sprouts = []; 
let lastAction = "";
let lastActionFrame = 0;

const NUM_SPROUTS = 7;
const PLANT_SCALE = 1.3;
const SEED = 3;

let actionButton;
let nextActionType = "water";

// Dataset: things plants say to the human who cares for them
const plantMessages = {
  water: [
    "Thank you for the water, my roots can reach a little deeper now.",
    "You came just when I was getting thirsty.",
    "Every drop you pour, I'll slowly turn into new leaves for you.",
    "Today's water tastes like you've been thinking of me.",
    "Being remembered by you feels even better than being watered."
  ],
  fertilize: [
    "This nourishment is whispering: it's okay to grow a bit bolder.",
    "I quietly grew a small new branch as a gift for you.",
    "Thank you, I'll remember this care with more flowers.",
    "I'm growing hard in places you cannot see.",
    "You gave me a reason to become a little more radiant."
  ],
  prune: [
    "Thank you for cutting away the parts that no longer fit me.",
    "Don't worry, I'll grow softer, newer leaves from these small wounds.",
    "You trimmed away not just dry leaves, but a little of my old heaviness.",
    "It's okay to be gentle, I can feel you trying not to hurt me.",
    "After your pruning, it suddenly feels easier to breathe."
  ]
};

// Sprout class
class Sprout {
  constructor(x, y) {
    let baseH = random(22, 32) * PLANT_SCALE;

    this.x = x;
    this.y = y;
    this.baseHeight = baseH;
    this.height = baseH + random(3, 10) * PLANT_SCALE;
    this.targetHeight = baseH + random(3, 10) * PLANT_SCALE;
    this.leaves = [];
    this.branches = [];
    this.wobbleOffset = random(0, 360);

    let initialLeaves = floor(random(2, 4));
    for (let i = 0; i < initialLeaves; i++) {
      this.addLeaf(random() < 0.5 ? -1 : 1);
    }
  }
  
  update() {
    this.height = lerp(this.height, this.targetHeight, 0.05);

    // Leaves turning yellow
    for (let leaf of this.leaves) {
      if (!leaf.isYellowing) {
        if (random() < 0.002) {
          leaf.isYellowing = true;
          leaf.yellowProgress = 0;
        }
      } else {
        leaf.yellowProgress += 0.002;
        leaf.yellowProgress = constrain(leaf.yellowProgress, 0, 1.2);
      }
    }

    // Flowers/branches withering
    for (let br of this.branches) {
      br.witherProgress += 0.0015;
      br.witherProgress = constrain(br.witherProgress, 0, 1.2);
    }
  }
  
  water() {
    this.targetHeight += random(25, 55) * PLANT_SCALE;
    if (random() < 0.6) this.addLeaf(random() < 0.5 ? -1 : 1);
  }
  
  fertilize() {
    this.targetHeight += random(15, 30) * PLANT_SCALE;
    if (this.branches.length < 6) this.addBranch();
  }

  //The following small piece of code, related to the "prune" topic, was generated by Chat GPT.
  prune() {
    let beforeL = this.leaves.length;
    this.leaves = this.leaves.filter(l => !(l.isYellowing && l.yellowProgress > 0.4));

    let beforeB = this.branches.length;
    this.branches = this.branches.filter(b => b.witherProgress <= 0.5);

    let removed = (beforeL - this.leaves.length) + (beforeB - this.branches.length);
    if (removed > 0) {
      this.targetHeight -= random(4 * removed, 10 * removed) * PLANT_SCALE;
      this.targetHeight = max(this.targetHeight, this.baseHeight);
    }
  }

  addLeaf(side) {
    if (this.leaves.length >= 6) return;

    this.leaves.push({
      side,
      offsetYFactor: random(0.5, 1.0),
      size: random(0.9, 1.3) * PLANT_SCALE,
      baseGreen: random(160, 220),
      isYellowing: false,
      yellowProgress: 0
    });
  }
  
  addBranch() {
    let num = floor(random(1, 3));
    let branch = {
      side: random() < 0.5 ? -1 : 1,
      offsetYFactor: random(0.4, 0.95),
      length: random(20, 40) * PLANT_SCALE,
      flowerSize: random(8, 14) * PLANT_SCALE,
      flowerColorFresh: [random(230,255), random(170,220), random(210,255)],
      flowerColorDead: [180,150,120],
      witherProgress: 0,// 0=fresh, 1=dead
      leaves: []
    };
    
    let t = random(0.3, 0.8);// t = position along branch  
    if (num === 1) {
      branch.leaves.push({
        t,
        side: random() < 0.5 ? 1 : -1,
        size: random(0.7, 1.1) * PLANT_SCALE,
        baseGreen: random(170,230)
      });
    } else {
      branch.leaves.push({ t, side: 1, size: random(0.7,1.1)*PLANT_SCALE, baseGreen: random(170,230) });
      branch.leaves.push({ t, side: -1, size: random(0.7,1.1)*PLANT_SCALE, baseGreen: random(170,230) });
    }
    this.branches.push(branch);
  }

  
  draw() {
    push();
    translate(this.x, this.y);

    let swayAmount = (3 +
      map(this.height, this.baseHeight, this.baseHeight + 80, 0, 4)) * (PLANT_SCALE * 0.8);
    swayAmount = constrain(swayAmount, 2, 10);
    let sway = sin(frameCount * 0.8 + this.wobbleOffset) * swayAmount;

    let stemThickness = map(this.height, this.baseHeight, this.baseHeight + 80, 1.5, 3.5) * PLANT_SCALE;
    stemThickness = constrain(stemThickness, 2.5, 5.5);

    stroke(70, 130, 70);
    strokeWeight(stemThickness);
    line(0, 0, sway, -this.height);

    // Leaves on main stem
    noStroke();
    for (let leaf of this.leaves) {
      let ly = -this.height * leaf.offsetYFactor;
      let lx = sway + leaf.side * (12 * PLANT_SCALE);
      let t = constrain(leaf.yellowProgress, 0, 1);
      fill(
        lerp(100, 190, t),
        lerp(leaf.baseGreen, 170, t),
        lerp(100, 100, t)
      );

      push();
      translate(lx, ly);
      rotate(leaf.side === 1 ? -30 : -150);
      ellipse(0, 0, 26 * leaf.size, 12 * leaf.size);
      pop();
    }

    // Branches + flowers
    for (let br of this.branches) {
      let by = -this.height * br.offsetYFactor;
      let bx = sway;
      let ang = br.side > 0 ? -45 : -135;
      let endX = bx + cos(ang) * br.length;
      let endY = by + sin(ang) * br.length;

      stroke(80, 140, 80);
      strokeWeight(2.2 * PLANT_SCALE);
      line(bx, by, endX, endY);
      noStroke();

      let dx = endX - bx;
      let dy = endY - by;
      let seg = sqrt(dx * dx + dy * dy);
      let nx = -dy / seg;
      let ny = dx / seg;
      let branchAngle = atan2(dy, dx);

      // Leaves on branch
      for (let bl of br.leaves) {
        let lx = lerp(bx, endX, bl.t);
        let ly = lerp(by, endY, bl.t);
        lx += nx * 6 * PLANT_SCALE * bl.side;
        ly += ny * 6 * PLANT_SCALE * bl.side;

        fill(90, bl.baseGreen, 90);
        push();
        translate(lx, ly);
        rotate(branchAngle + bl.side * 30);
        ellipse(0, 0, 18 * bl.size, 9 * bl.size);
        pop();
      }


      // Flower
      let t2 = constrain(br.witherProgress, 0, 1);
      fill(
        lerp(br.flowerColorFresh[0], br.flowerColorDead[0], t2),
        lerp(br.flowerColorFresh[1], br.flowerColorDead[1], t2),
        lerp(br.flowerColorFresh[2], br.flowerColorDead[2], t2)
      );

      push();
      translate(endX, endY);
      ellipse(0, 0, br.flowerSize * 1.4);
      fill(255, 230, 150);
      ellipse(0, 0, br.flowerSize * 0.4 * 1.4);
      pop();
    }

    pop();
  }
}


// Random next action
function randomNextAction() {
  let r = random();
  if (r < 0.33) return "water";
  else if (r < 0.66) return "fertilize";
  else return "prune";
}

// Pick a random sentence from the dataset
//The following short piece of code, the randomPlantMessage function, was generated by Chat GPT.
function randomPlantMessage(type) {
  let arr = plantMessages[type];
  if (!arr || arr.length === 0) return "";
  let idx = floor(random(arr.length));
  return arr[idx];
}

function setup() { 
  createCanvas(800, 800);
  angleMode(DEGREES);
  randomSeed(SEED);

  for (let i = 0; i < NUM_SPROUTS; i++) {
    let x = map(i, 0, NUM_SPROUTS - 1, 100, width - 100) + random(-15, 15);
    let y = random(615, 640);
    sprouts.push(new Sprout(x, y));
  }

  nextActionType = randomNextAction();
  createActionButton();
  updateButtonLabel();
}


function draw() {
  background(240);

  // Ground
  noStroke(); 
  fill(200, 180, 150);
  rect(0, 600, width, 200);

  // Plants
  for (let s of sprouts) {
    s.update();
    s.draw();
  }

  drawLastAction();
}

// One DOM button
function createActionButton() {
  actionButton = createButton("");
  actionButton.position(width -180, height - 60);
  styleButton(actionButton);

  actionButton.mousePressed(() => {
    performAction(nextActionType);
    nextActionType = randomNextAction();
    updateButtonLabel();
  });
}

function updateButtonLabel() {
  if (nextActionType === "water") {
    actionButton.html("Next: Water ðŸ’§");
  } else if (nextActionType === "fertilize") {
    actionButton.html("Next: Fertilize ðŸŒ¸");
  } else {
    actionButton.html("Next: Prune âœ‚ï¸");
  }
}

function performAction(type) {
  if (type === "water") {
    for (let s of sprouts) s.water();
  } 
  else if (type === "fertilize") {
    for (let s of sprouts) s.fertilize();
  } 
  else {
    for (let s of sprouts) s.prune();
  }

  // Plant speaks to the human after the action
  lastAction = randomPlantMessage(type);
  lastActionFrame = frameCount;
}

function styleButton(btn) {
  btn.style("font-size", "18px");
  btn.style("padding", "10px 20px");
  btn.style("border", "none");
  btn.style("border-radius", "8px");
  btn.style("background", "#7cb36f");
  btn.style("color", "white");
  btn.style("cursor", "pointer");
}

// Text at the bottom now (plant dialogue)
function drawLastAction() {
  if (lastAction === "") return;
  let age = frameCount - lastActionFrame;
  if (age > 340) return;// fade timeout

  push();
  fill(255);
  textSize(17.5);
  text(lastAction, 20, height - 25);
  pop();
}
